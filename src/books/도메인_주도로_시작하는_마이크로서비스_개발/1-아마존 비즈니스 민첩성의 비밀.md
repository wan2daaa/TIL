## 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

아마존, 넷플릭스, 우버 등의 성공한 유니콘 기업들의 공통점 ? 
- 이미 익숙한 비즈니스에 새로운 비즈니스 개념과 기술을 융합해 자신만의 특화된 서비스를 제공한다
- 이런 기업들은 **자신만의 특화된 서비스를 제공하려는 시도를 누구보다 빨리 실행**했고, 
- **사용자 피드백을 반영해 끊임없이 서비스를 개선**
- 이러한 기업들의 특출난 장점을 -> **비즈니스 민첩성**을 꼽고 (**Agility**), 이것이 기업 성공의 가장 큰 요인

### 1.1.1 성공 사례: 아마존의 배포 속도 
- 2011년 11.6초 = 아마존의 비즈니스 서비스가 배포되는 주기
- 2019년 초당 1.5번


**비즈니스는 계속 변경**되므로 이에 따라 -> **개선된 시스템도 계속 배포** 해야한다

새로운 아이디어, 기존 서비스 보완, 새로운 서비스 개선 할때도 -> **시스템을 빠르게 변경해서 배포해야한다**

- 빠른 배포 주기는 = 비즈니스의 민첩성을 간접적으로 보여주는 지표

### 1.1.2 클라우드 인프라의 등장 

전형적인 시스템 인프라 구축 과정

서버 도입 -> 네트워크 구축 -> 각 서버마다 운영체제 설치 -> 서비스에 필요한 소프트웨어를 설치

- 애플리케이션을 개발하기 위한 인프라 환경을 준비하는 작업은 간단하지 않고 오래 걸린다. 
- 좋은 아이디어가 있고, 직접 개발할 수 있어도 빨리 서비스를 런칭할 수 없다.

- 이런 문제가  **클라우드 인프라**의 등장으로 해결됨!

### 1.1.3 클라우드 인프라에 어룰리는 애플리케이션의 조건 

- 클라우드 인프라를 사용하면 사용량에 따라 비용을 유연하게 조정할 수 있다!
  - 즉, 사용한 만큼만 비용을 지불하면된다.
- 트래픽이 몰릴 때 시스템 용량을 증설하고, 트래픽이 덜 몰라면, 시스템 용량을 줄인다. 


그럼 실제로 서비스를 제공하는 애플리케이션 측면을 살펴보자.

- 비즈니스 민첩성을 지원하기 위해 -> **인프라와 마찬가지로** 
  - **필요한 시점에 필요한 만큼만 애플리케이션을 변경해 배포하면 좋지 않을까?** 
  - **클라우드 인프라를 닮으면 되지 않을까?**


- 클라우드는 여러 개의 서버 장치가 모여 논리적으로 하나처럼 관리된다.
  - 즉, 레고처럼 하나의 큰덩어리가 되기도 하고, 쉽게 분리되기도 한다
- 애플리케이션도 레고와 같으면 효율성을 극대화 할 수 있지 않을까? 
- 애플리케이션의 블록이 작으면 작을수록 효율적이다!
- 특히 사용량이 증가할 운영 시점이라면 -> 서비스 비용을 유연하게 관리할 수 있다

#### 스케일 업과 스케일 아웃 
사용량 증가에 따른 성능 및 가용성을 높이는 방법 

**스케일 업** (수직 확장) 
- 기존 시스템 자체의 물리적 용량을 증가시켜 성능을 높이는 방법
- 사용량이 많아진다는 것은 -> 데이터 처리가 증가한다는 것, 시스템을 담을 그릇도 커져야 한다!

**스케일 아웃** (수평 확장)
- 기존 시스템과 **용량이 같은 다수의 장비를 병행 추가**해서 가용성을 높이는 방법
  - 즉, 사용량을 분산시켜 전체적으로 장애없이 운영하게 된다!
- 특정 서비스만 탄력성 있게 확장 할 수 있다.



> - 클라우드 인프라가 등장하면서 인프라를 쉽게 구축할 수 있게 됐다.
> - 클라우드 인프라에서 유연하게 구축할 수 있어서 애플리케이션도 이 구조와 유사하게 닮으면 좋지 않을까? 
> - 서버가 쪼개지면서 트래픽이 몰리는 특정 서비스에 스케일 아웃을 하면서 비용적으로도 절감할 수 있다. 

## 1.2 마이크로서비스란 무엇인가?
아키텍처 스승이라고 불리는 마틴 파울러는 그동안의 마이크로서비스 발전 흐름을 정리해 마이크로서비스의 등장 배경과 개념, 특징을 설명한 바 있다. 
 [마틴 파울러 - microservices](https://martinfowler.com/articles/microservices.html)

### 1.2.1 모노리스와 마이크로서비스 비교 
먼저 전통적인 시스템 구조인 모놀리스 구조부터 시작하자 
- 모노리스는 하나의 단위로 개발되는 일체식 애플리케이션 
- 보통 3티어라고 불리는 사용자 인터페이스와 데이터베이스, 서버 쪽 애플리케이션의 3개 부분으로 구성됨 ! 

> **참고**
> - **티어** : 서버와 같은 문리적인 분리 
> - **레이어** : 논리적인 분리
> - 하나의 티어 내부를 여러 개의 논리 레이어로 나눌 수 있다! 

- 서버 측 애플리케이션이 일체, 즉 논리적인 단일체 
  - 아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 한다!
- 그리고 일체식 애플리케이션은 = 단일 프로세스에서 실행된다
  - -> 따라서 확장이 필요할 경우, 특정 기능만 확장할 수 없고, 반드시 전체 애플리케이션을 동시에 확장해야 한다 
  - 보통, 로드 밸런서를 앞에 두고, 여러 인스턴스 위에 큰 덩어리를 복제해 수평으로 확장

**단점**
- 이런 상황에서 변경이 발생하면 모노리스 시스템의 단점이 극대화 
  - 즉, 여러 개의 모노리스가 수평으로 확장된 상태라 **여러 개의 모노리스 시스템 모두를 전부 다시 빌드하고 배포**해야 한다.
- 또한, 확장 시 애플리케이션이 병렬로 확장되어 사용량 증가에 대응할 수 있지만 
  - **데이터베이스는 통합되어 하나이므로 탄력적으로 대응할 수 없다.**
- 따라서 사전에 성능을 감당하기 위해 스케일 업을 통해 용량을 증설해야 한다.

#### 마이크로서비스
- 서버 측이 여러 개의 조각으로 구성돼 각 서비스가 별개의 인스턴스로 로딩된다.
  - 즉, 여러 서비스 인스턴스가 모여 -> 하나의 비즈니스 애플리케이션을 구성
- 또한, 각기 저장소가 다르므로 ->  **업무 단위로 모듈 경계가 명확하게 구분**된다.
  - 따라서 확장 시에는 **특정 기능별로 독립적으로 확장**할 수 있고,
  - 특정 서비스를 변경할 필요가 있다면 -> 해당 서비스만 빌드해서 배포하면 된다.
- 또, 각 서비스가 독립적이어서 서로 다른 언어로 개발하는 것도 가능 -> 각 서비스의 소유권을 분리해 서로 다른 팀이 개발 및 운영 할 수 있다 



### 1.2.2 SOA와 마이크로서비스
소프트웨어 공학에서 말하는 모듈화 개념의 발전 흐름을 보면 
1. 단순히 기능을 하향식 분배해서 설계해 나가는 **구조적 방법론**
2. 객체 단위로 모듈화하기 위한 **객체지향 방법론**
3. 모듈화의 단위가 기능별로 재사용할 수 있는 좀더 큰 컴포넌트가 되는 **CBD**
4. 컴포넌트를 모아 비즈니스적으로 의미 있고, 완결적인 서비스 단위로 모듈화 하는 **SOA**


-> 따라서 CBD와 SOA도 넓게 보면, 단위 컴포넌트나 서비스를 구성해서 시스템을 만드는 개념이고, 

이는 마이크로서비스 시스템의 구조와 매우 유사!

- 보통 마이크로서비스 기반으로 시스템을 개발하는 아키텍처 및 개발 방식을 MSA라고 하는데, 
- 그렇다면 서비스 기반 아키텍처를 칭하는 SOA와는 어떤 개념적 차이가 있을까?


넓게 보면 여러 개의 응집된 비즈니스 서비스의 집합으로 시스템을 개발한다는 점에서 SOA와 MSA는 개념적으로 큰 차이가 없다
- 그러나 SOA는 구체적이지 않고 이론적, 실제 비즈니스 성공 사례가 많지 않았다
- 반면, MSA는 클라우드 인프라 기술의 발전과 접목되어 아마존과 넷플릭스에 의해 구체화되고 여러 성공 사례가 공유됨
  

> 즉, 이상적이었지만, 성공을 증명하지 못했던 SOA가 클라우드 인프라의 등장으로 하드웨어를 유연하게 다룰 수 있게 되면서 비로소 실현되어 성공적으로 증명된 시스템 구조가 MSA!



#### 마틴 파울러가 말하는 마이크로서비스의 정의 
> 마이크로 서비스는 **여러 개의 작은 서비스 집합으로 개발하는 접근 방법**
> 
> 각 서비스는 개별 프로세스에서 실행되고, HTTP 자원 API같은 가벼운 수단을 사용해서 통신한다.
> 
> 또한 **서비스는 비즈니스 기능 단위로 구성**되고, 자동화된 배포 방식을 이용하여 독립적으로 배포된다. 
> 
> 또한, 서비스에 대한 중앙 집중적인 관리는 최소화하고, 각 서비스는 서로 다른 언어와 데이터, 저장 기술을 사용할 수 있다


- 각 서비스와 저장소는 다른 서비스 및 저장소와 격리 되어 있는 구조 
- API를 통해서만 **느슨하게 연계**
  - -> 따라서 독립적으로 확장 가능하고, 하나의 서비스만 독립적으로 배포 가능하다
- 또한, 다른 서비스와 연계된 API에 영향을 주지 않는다면 -> 내부의 언어나 저장소는 자율적으로 선택할 수 있다.
- 이처럼 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 가리켜 **폴리글랏 하다**라고 표현!
  - 클라우드 등의 가상 인프라가 지닌 유연성이 이를 가능하도록 지원한다!



**CBD/SOA 의 아쉬운 점**
- 애플리케이션은 모듈별로 분리했으나, 데이터 저장소까지는 분리하지 못헀다.
  - ->따라서 **데이터의 강한 결합**으로 애플리케이션도 독립적으로 사용하기가 힘들었다.

**MSA가 CBD/SOA와 다른 점**
- 그러나 MSA에서는 SOA에 없었던 다음의 두 가지 개념으로 모듈화 방식을 강화 했다 
1. **서비스별 저장소를 분리**해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화. 즉, 다른 서비스의 저장소에 접근하는 수단은 API 밖에 없다.
2. REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다.

- 이것이 바로 MSA 시스템의 구조를 SOA와 구분하는 큰 차이점이자 **모듈화를 극대화하는 특징**


## 1.3 마이크로서비스를 위한 조건은 무엇인가? 
마틴 파울러가 언급한 MSA의 주요 특징을 좀 더 살펴보자 

- 특히 이번에 설명할 특징들은 **마이크로서비스를 잘 구현하고 있는 조직들의 사례**이며,
- 동시에 **마이크로서비스를 구현하기 위한 필요 조건**이 된다.

- 이러한 시각은 MSA의 성공이 **CBD,SOA처럼 기술에만 의존한 아키텍처 스타일을 추구하는 데 그치지 않고** 
- **개발 환경, 문화, 일하는 방식과도 연계**돼 있음을 보여준다. 

### 1.3.1 조직의 변화: 업무 기능 중심 팀
콘웨이의 법칙은 멜빈 콘웨이가 정의한 / **조직과 조직이 개발한 소프트웨어의 관계를 정의한 법칙**

쉽게 설명하면 시스템을 개발할 때 항상 시스템의 모양이 팀의 의사소통 구조를 반영하는 것을 말한다

**예전의 일하는 방식**
- 하나의 애플리케이션을 만드는 데 UI팀, 서버 개발팀, DB팀과 같은 기술별로 팀이 나눠져 있고, 
- 하나의 애플리케이션을 만드는 데는 세 팀간의 의사소통이 필요하다 
  - -> 따라서 시스템도 이러한 의사소통 구조를 그대로 반영하고, 
  - 이러한 팀 구조에서는 팀 간의 의사결정도 느리고, 의사소통도 어렵다.


**마이크로서비스의 방식**
- 마이크로서비스를 만드는 팀은 **업무 기능 중심의 팀이어야 한다.**
- 업무 기능 중심 팀은 역할 또는 기술별로 팀이 분리되는 것이 아니라,
  - **업무 기능을 중심으로 기술이 다양한 사람들이 하나의 팀이 되어 서비스를 만드는 것**을 의미 
- 업무 기능 중심 팀은 다양한 역할(기획자, 디자이너, 프런트엔드, 백엔드, 설계자, QA 등)으로 구성되고, 
- 이 팀은 **서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 모두 갖추고 있다**.
- 이 팀은 같은 공간, 같은 시간을 공유하기 때문에 -> **의사소통도 원활하고 의사결정도 빠르게 진행**될 수 있다.


- 이 팀을 여러 기능들이 모여 있다는 의미에서 **다기능 팀**이라고도 한다
  - 자율적으로 담당 비즈니스에 관련된 서비스 + **개발 이후에 운영할 책임까지 진다.**

- 콘웨이의 법칙에 의헤 이 팀이 만든 마이크로서비스도 다른 팀이 만든 마이크로서비스와는 느슨하게 연계된다



### 1.3.2 관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏









