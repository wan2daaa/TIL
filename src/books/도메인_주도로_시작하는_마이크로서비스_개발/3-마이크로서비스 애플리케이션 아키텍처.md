로버트 C. 마틴은 `클린 아키텍처`에서 소프트웨어의 가치는 **행위 가치** 와 **구조 가치**로 나뉘고,

소프트웨어를 정말로 부드럽게(Soft)하게 만드는 것은은 구조 가치라고 언급했다. 

- 행위 가치 : 소프트웨어의 기능 
- 구조 가치 : 소프트웨어 아키텍처

- 코드와 설계의 구조를 깔끔하게 만들려는 생각을 하지 않고, 기능 구현만 목적으로 삼으면 
  - -> 소프트웨어가 엉망이 된 상황에 대처하는 데 더 많은 비용이 든다는 점을 강조


- 특히 개발과 운영을 모두 책임지고 있는 마이크로서비스팀 입장에서는 소프트웨어의 초기 개발 뿐만아니라, 
- **지속적인 비즈니스의 변화에 빠르게 대응할 수 있는 구조가 필요**한데, 
- **소프트웨어가 부드럽지 않다면 기민하게 대응하기 어려울 것**이다.


## 3.1 비즈니스 로직은 어디에? - 관심사의 분리 
- 소프트웨어의 핵심은 **비즈니스 로직**
- 비즈니스 로직이란, 보통 시스템의 목적인 비즈니스 영역의 업무 규칙(Rule), 흐름(Flow), 개념(Concept)을 표현하는 용어
- 개발자의 역할은 **문제 영역의 비즈니스 로직을 분석/이해하고** -> **프로그래밍 언어라는 도구로 잘 표현하는 일**
  - 여기서 잘 표현한다 라는 것은 기능이 잘 동작하는 것 + **이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것을 의미** 

- 설계 원칙 중 **관심사의 분리** 라는 원칙이 있다. 
  - 관심사의 분리란, **시스템의 각 영역이 처리하는 관심사가 분리되어 잘 관리돼야 한다**는 의미
  - 이 원칙은 **시스템을 이해하고 변경하기 쉽게 만들어준다.**
- 이 원칙에 따라 **각 영역은 고유 관심사에 의해 분리되고 집중**돼야 한다.


- 모듈화 및 계층화도 이 같은 원칙에 기인한다. 
  > 특히 **비즈니스를 표현하는 비즈니스 로직 영역** 과 **기술 문제를 처리하기 위한 기술 영역**은 철저히 분리하는 것이 좋다.


기술과 비즈니스 로직을 분리했을 때 -> 복잡성이 낮아지고, 유지보수성도 높아진다. 


애플리케이션의 유지보수성이 높다는 의미는
- = 특정 개인에 의존하기보다는 **어느 누구라도 손쉽게 애플리케이션을 이해하고 유지보수할 수 있음**을 의미


기술과 비즈니스 로직을 분리해서 기술의 변화에도 비즈니스 로직이 영향받지 않고 쉽게 변경 및 확장이 가능한 바람직한 MS 내부 구조에 대해서 알아보자

### 3.1.1 데이터베이스 중심 아키텍처의 문제점
데이터베이스 중심 아키텍처란
- 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 다음 
- 이 **물리 테이블 모델을 중심에 두고**, 애플리케이션을 구현하기 위한 사고를 하는 방식


- 이러한 구조에서는 일반적으로 비즈니스 로직은 서비스에 존재해야 한다고 말하지만, 
- **서비스에 존재하게 될 로직은 흐름 제어 로직밖에** 없다.
- 이 구조는 애플리케이션 로직 구성 패턴 중 하나인 **트랜잭션 스크립트 구조**와 비슷


- **앞에서 비즈니스 민첩성을 위해서는 유연성과 확장성이 중요하다**
- 대부분의 성능을 데이터베이스에 의존한다.
  - 서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현되기 때문

- 데이터베이스의 본질은 데이터 저장 처리이고 여기에 최적화 되어있다.
- SQL도 비즈니스 로직을 처리하기 위한 언어가 아니라 -> **데이터 처리에 최적화된 언어**
- 클라우드 인프라를 제대로 활용하기 어렵다 (스케일 업만 가능하니까)
- 즉, 클라우드의 풍부한 자원 환경에서는 애플리케이션 자체의 성능보다는 **애플리케이션의 확장성과 유연성이 더 중요하다**


## 3.2 헥사고날 아키텍처와 클린 아키텍처 
레이어드 아키텍처를 설명하고, 

최근의 마이크로서비스 설계자들이 마이크로서비스의 **내부 구조를 유연하게 구성하기 위해 적용하는** 헥사고날 아키텍처, 클린아키텍처에 대해 알아보자    


### 3.2.1 레이어드 아키텍처
레이어드 아키텍처를 구성하는 **레이어**는 논리적인 개념이다 (물리적인 티어와 다른 개념)

물리적인 서버 티어의 레이어(계층)을 프레젠테이션, 비즈니스 로직, 데이터 엑세스의 3가지 논리적인 계층으로 구분할 수 있다. 

- 계층은 설계자들이 복잡한 시스템을 분리할 때 흔히 사용하는 패턴 중 하나, 
- = 애플리케이션이 내부에서 처리하는 **관심사를 논리적으로 구분**

| 레이어     | 관심사 (기능)          |
|---------|-------------------|
| 프레센테이션  | 화면 표현 및 전환 처리     |
| 비즈니스 로직 | 비즈니스 개념, 규칙, 흐름제어 |
| 데이터 엑세스 | 데이터 처리            |


#### 레이어드 아키텍처 규칙 
- 상위 계층이 -> 하위 계층을 호출하는 단방향성을 유지
- 상위 계층은 **하위의 여러 계층을 모두 알 필요 없이**, **바로 밑의 근접 계층만 활용**
- 상위 계층이 하위 계층에 영향을 받지 않게 구성해야 한다
- 하위 계층은 **자신을 사용하는 상위 계층을 알지 못하게** 구성
- 계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직 (구현 클래스에 직접 의존하지 않음으로써 -> **약한 결합을 유지**)


특히 인터페이스를 통한 의존성 분리는 **인터페이스를 구현하는 구현체를 다양하게 해주는 다향성을 추구함으로써** -> **제어 흐름을 간접적으로 전환**하게 해준다.

- DIP를 만족하는 것 처럼 보이지만, OCP까지 살펴본다면 문제가 있다. 
- OCP는 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다는 원칙

- 일반적인 레이어트 아키텍처에서 OCP 가 위배되는 까닭은
- 모든 계층이 각기 **자신이 제공하는 기능에 대한 추상적인 인터페이스를** -> **직접 정의하고 소유하고 있는 구조**이기 때문
- 이런 구조에서는 제어 흐름(flow of control)이 **상위 계층에서 하위 계층으로 흐르게 되고**,
  - 이에 따른 **소스코드의 의존성은 제어 흐름의 방향대로 따를 수 밖에 없다**.
- 다형성과 의존성은 줄일 수 있지만, 인터페이스는 **그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다.**


- -> 따라서 하위 계층의 유형이 추가되어 확장될 때 -> 닫혀 있어야 할 상위 계층이 하위 계층에서 정의한 특성에 영향을 받게 된다. 


### 3.2.2 헥사고날 아키텍처 
그러나 레이어드 아키텍처에 DIP를 적용해도 한계가 있다. 

- 현대 애플리케이션에서는 프레젠테이션 계층과 데이터 엑세스 계층 말고도 다양한 인터페이스가 필요하다 
  - -> 즉, 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 존재

- 단방향 계층구조에서는 이러한 점을 지원하기 힘들다.
- 다방면으로 열려 있는 헥사고날 아키텍처는 이러한 문제점을 해결할 수 있다. 
---
**설명**
- 포트 앤 어댑터 아키텍처 라고 한다. 
- **고수준의 비즈니스 로직을 표현하는 내부 영역** / **인터페이스 처리를 담당하는 저수준의 외부 영역**으로 나눈다.

 
**내부 영역**
- 내부 영역은 **순수한 비즈니스 로직을 표현하는 기술 독립적인 영역**
- 내부 영역은 외부 영역과 연계되는 포트를 가지고 있다.

**외부 영역** 
- 외부에서 들어오는 -> 요청을 처리하는 인바운드 어탭터와 
- 비즈니스 로직에 의해 호출되어 -> 외부와 연계되는 아웃바운드 어댑터


**특징**
- 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게 한다는 것
- 이를 가능하게 하는 것이 **내부 영역에 구성되는 포트**

- 포트는 인바운드/아웃바운드 포트로 구분, 
  - 인바운드 포트는 : 내부 영역의 사용을 위해 표출된 API -> 외부 영역의 인바운드 어댑터가 호출
  - 아웃바운드 포트는 : 내부 영역이 외부를 호출하는 방법

- 여기서 DIP원칙과 같이 
- 아웃바운드 포트가 외부의 아웃바운드 어댑터를 호출해서 -> 외부 시스템과 연계하는 것이 아니라 
- 아웃바운드 어댑터가 -> 아웃바운드 포트에 의존해서 구현된다.

### 3.2.3 클린 아키텍처 
마틴은 소프트웨어는 행위 가치와 구조 가치의 두 종류의 가치를 가지며, **구조 가치가 더 중요하다**

- 소프트웨어를 부드럽게 만드는 것이 중요!

**소프트웨어를 부드럽게 유지하는 방법?**
- 구조 중에서 **선택할 수 있는 것**을 -> **가능한 오랫동안 열어두는 것**
- 특히 **열어둬야 할 선택 사항**은 = **중요하지 않은 세부 사항**


##### **엔티티**
- 업무 규칙이 있다 
- 업무 규칙은 사업적으로 수익을 얻거나, 비용을 줄일 수 있는 규칙 또는 절차
- 모든 시스템에는 **도메인의 업무를 규정하는 핵심 업무 규칙이 존재**한다.
  - 그리고 핵심 업무 규칙은 보통 데이터를 요구

> -> 따라서 **핵심 규칙과 데이터는 본질적으로 결합**돼 있기 때문에 -> 객체로 쉽게 만들 수 있다. <- 이를 **엔티티** 객체!

##### **유스케이스**
- 유스케이스는 자동화된 **시스템을 사용하는 처리 절차를 기술**
- 유스케이스는 **애플리케이션에 특화된 업무 규칙을 표현**
- **엔티티 내부의 핵심 업무 규칙을 호출**하며 **시스템을 사용하는 흐름을 담는다.**
- 이때 **엔티티 같은 고수준 영역**은 -> **저수준의 유스케이스 영역을 알게 해서는 안 된다.**
- **엔티티는 간단한 객체** 여야 하고, 
- 프레임워크 데이터베이스 또는 기타 **복잡한 것에 의존해서는 안되고**, **유스케이스 객체를 통해서만 조작해야 한다**


- 유스케이스를 감싸고 있는 나머지 모든 영역이 **세부사항**
- 세부사항과 유스케이스의 관계를 **의존 관계 역전의 원칙을 이용**해 플러그인처럼 유연하게 처리해야 한다.
- 이처럼 명확한 결합의 분리는 
  - 테스트 용이성
  - 개발 독립성
  - 배포 독립성을 강화할 수 있다.


## 3.3 마이크로서비스의 내부 구조 정의 

### 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스 


##### 내부 구조 원칙 
- 지향하는 **관심사에 따라 응집성을 높이고**, **관심사가 다른 영역과는 의존도를 낮추게**해야 한다.
- 업무 규칙을 정의하는 비즈니스 로직 영역을 **다른 기술 기반 영여긍로부터 분리하기 위해 노력**해야 한다.
- 세부 기술 중심, 저수준의 외부 영역 / 핵심 업무 규칙이 정의된 고수준의 내부 구현으로 구분한다.
- 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 -> 고수준 영역에 의존하게 해야 한다.
- 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 된다.
- 자바처럼 인터페이스 및 추상 클래스를 지원하는 언어의 경우, **저수준 영역의 구체 클래스가 -> 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전의 원칙을 적용**한다.
- 인터페이스는 **고수준의 안정된 영역에 존재**해야 하며, **저수준의 어댑터가 이를 구현**한다.


---

- 내부 영역에서는 맨 안쪽에 도메인이 존재, 도메인을 서비스가 감싼다.
- **도메인**에는 **핵심 비즈니스 개념과 규칙을 구현**하며, 
- **서비스**에서는 **도메인을 호출해서 업무를 처리하는 절차를** 기술
- 또한, 외부 영역과 연계하기 위해 서비스 인터페이스를 보유
- 서비스 인터페이스(use case)는 **외부에서 내부 영역을 사용할 수 있도록 API를 제공**하고 서비스가 이를 구현










