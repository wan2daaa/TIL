객체 지향이 주는 장점은 구현 변경의 유연함 

앞선 [객체지향.md](./1-객체지향.md)에서는 **캡슐화**를 통해 
- 객체를 사용하는 다른 코드에 영향 최소화, 
- 객체의 내부 구현을 변경할 수있는 유연함

을 얻을 수 있었다.

이 markdown에서는 **추상화**가 주는 유연함에 대해 알아보자

### 상속 
상속(inheritance)은 한 **타입을 그대로 사용하면서** **구현을 추가할 수 있도록 해주는 방법**

## 다형성
다형성(Polymorphism)은 한 객체가 여러가지 모습을 갖는다는 것을 의미
- 여기서 모습은 타입을 의미!
- 즉, **다형성이란 한 객체가 여러 타입을 가질 수 있다는 것**


- 타입 상속은 크게 인터페이스 상속 / 구현 상속으로 구분할 수 있다.

## 추상 타입과 유연함 
추상화(abstraction)은 데이터나 프로세스 등을 **의미가 비슷한 개념이나 표현으로 정의하는 과정**

- 여러 기능들이 존재하는데 , 의미가 비슷한 개념을 추상화해서 하나의 큰 개념으로 정의할 수 있는 것
- **추상화된 타입**은 오퍼레이션의 시그니처만 정의할 뿐, 실제 구현 제공 X

> 참고 
> 
> **추상화**
> - 위에서는 클래스에서 추상 타입을 이끌어내는 추상화를 언급했지만, 
> - 추상화는 더 다양하다. 
> - 추상화를 한다고 해서 반드시 추상타입 만들어야 하는 것은 아니다 
> - e.x. 모델링
> - 추상화를 단순히 ** 구현 클래스로부터 -> 추상타입을 이끌어 내는 것만이 추상화라고 오해하면 안된다!**



#### 추상 타입과 실제 구현의 연결 
- 추상 타입과 <-> 실제 구현 클래스는 **상속**을 통해서 연결한다.
- 즉, **구현 클래스가 추상 타입을 상속받는 방법으로 연결!**

#### 추상 타입을 이용한 구현 교체의 유연함 
- 구체 클래스를 사용하면, 해당 구현 클래스를 사용하는 **다른 객체에서 자신의 책임과 상관없는 구현 교체의 변경으로 인해 변경이 된다.**


##### 추상화 전
```java
public class FlowController {
    private boolean useFile;
    
    public FlowController(boolean useFile) {
        this.useFile = useFile;
    }
    
    public void process() {
        byte[] data = null;

        /**
         * FlowController은 흐름제어의 책임이 있는데, 
         * 책임에 맞지 않는 어떤 구체 클래스에 사용하느냐에 따라 코드가 변경된다.
         */
        if (useFile) {
            FileDataReader fileReader = new FileDataReader();
            data = fileReader.read();
        }else {
            SocketDataReader sockerReader = new SocketDataReader();
            data = socketReader.read();
        }
        
        Encryptor encryptor = new Encryptor();
            
        
        FileDataWriter writer = new FileDataWriter();
        writer.write(encrytor.encrypt(data));
    }
}
```

##### 추상화 후 
```java
public class FlowController {
    private boolean useFile;
    
    public FlowController(boolean useFile) {
        this.useFile = useFile;
    }
    
    public void process() {

        /**
         * 코드가 훨씬 나아졌지만, 아직 구현 클래스를 생성하는 부분이 포함되어있고, 
         * 콘크리트 클래스가 변경될 떄마다 함께 변경된다.
         */
        ByteSource byteSource = null;
        
        if (useFile) {
            byteSource = new FileDataReader();
        }else {
            byteSource = new SocketDataReader();
        }
        
        byte[] data = byteSource.read();
        
        ...
    }
}
```


### 콘크리트 클래스가 변경되더라도 다른 객체에 영향을 안주는 방법 

1. 타입 객체를 생성하는 기능을 별도 객체로 분리한 뒤 -> 그 객체를 사용해서 타입 객체를 생성
2. 생성자(또는 다른 메서드)를 이용해서 사용할 콘크리트 클래스를 전달하기 



> 추상화는 공통된 개념을 도출해서 -> **추상 타입을 정의**해주기도 하지만, 
> 
> **많은 책임을 가진 객체로부터 책임을 분리하는 촉매제**가 되기도 한다!



#### 변화되는 부분을 추상화하기 
- 변화되는 부분을 추상화 하려면 다양한 환경에서 많은 경험이 필요하다 
- 경험하지 않은 분야라 하더라도 추상화할 수 있는 방법이 하나 있는데, 
  - **변화되는 부분을 추상화**
- 요구사항이 바뀔 때 변화되는 부분은 이후에도 변경될 소지가 많다

-  **추상화 되어있지 않은 코드는 주로 동일 구조를 갖는 if-else 블록으로 드러난다**

- 변화되는 부분을 추상화함으로써, 새로운 기능 추가 요구가 발생했을때
  - -> **추상 타입을 사용하는 코드에 수정하지 않거나, 수정을 최소화 가능!**


#### 인터페이스에 대고 프로그래밍하기
객체 지향의 유명한 규칙중 하나 

- 여기서 말하는 인터페이스는 자바의 interface가 아니라, **오퍼레이션을 정의한 인터페이스**

- 즉, **실제 구현을 제공하는 콘크리트 클래스를 사용해서 프로그래밍 하지말고, **
  - -> **기능을 정의한 인터페이스를 사용해서 프로그래밍 해라!**

- 하지만, 인터페이스는 최소 설계에서 바로 도출되기 보다는, 
  - -> **요구사항의 변화와 함께 점진적으로 도출 된다!**
- 즉, **인터페이스는 새롭게 발견된 추상 개념을 통해서 도출되는 것**

- 인터페이스에 대고 프로그래밍 하기 규칙은 **추상화를 통한 유연함을 얻기 위한 규칙!**

**주의할 점**
- 유연함을 얻는 과정에서 타입(추상 타입)이 증가하고, 구조도 복잡해지기 때문에
  - -> **모든 곳에서 인터페이스를 사용해서는 안된다**
  - 불필요하게 복잡도가 증가시킬 수 있다. 


**인터페이스는 변화 가능성이 높은 경우에 한해서 사용해야 한다!**


#### 인터페이스는 인터페이스 사용자 입장에서 만들기
- 인터페이스 명을 명확하게 만들어서 인터페이스 명으로 인터페이스 사용자가 어떤 기능을 사용할 수 있는지 알 수 있도록 해야 한다.


#### 인터페이스와 테스트 
- 인터페이스를 사용해서 프로그래밍하면, **실제 콘크리트 클래스 대신에 진짜처럼 행동하는 객체를 Mock**을 홣용해서 테스트 할 수있다. 