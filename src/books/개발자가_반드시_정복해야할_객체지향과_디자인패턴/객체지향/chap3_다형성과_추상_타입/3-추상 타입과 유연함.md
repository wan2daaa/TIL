### 추상화

- 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정

#### 예시
만약 어떤 프로그램을 만드는데 다음과 같은 세 개의 기능이 있다고 해보자 
- FTP에서 파일 다운로드 
- 소켓에서 데이터 읽기 
- DB 테이블의 데이터를 조회 

위 세 가지 기능은 모두 로그를 수집하기 위한 기능 이였다.

- 이 세 기능은 모두 '로그 수집'이라는 프로세스를 처리하는 과정 
- 즉, 이 세 기능을 추상화하면 '로그 수집'이라는 개념으로 정의할 수 있는 것


**추상화된 타입**은 오퍼레이션의 시그니처만 정의할 뿐, **실제 구현을 제공하지는 못한다.**

- 추상 타입만으로는 FTP에서 로그파일을 다운할지, 소켓에서 읽을지, 여부를 알 수 없다. 
- 단지, **로그 정보를 수집한다는 의미만 제공할 뿐**
- 추상 타입은 구현을 제공할 수 없기 때문에
  - -> 보통 구현을 제공하지 않는 타입 == 인터페이스나  C++ 추상 클래스로 정의한로만 구성된 추상 클래스
  - 를 이용해서 추상타입을 정의


> 추상화는 단순히 추상 타입을 이끌어낼 뿐만 아니라, 
> 객체 모델링 역시 추상화다
> - 객체 클래스는 개별 직원들을 추상화한 결과물 일 수도있고, 
> - **단순히 구현 클래스로부터 추상 타입을 이끌어 내는 것만이 추상화라고 오해하면 안됨!**


## 추상 타입과 실제 구현의 연결 

- 추상 타입과 실제 구현 클래스는 상속을 통해서 연결
  - 구현 클래스가 추상 타입을 상속받는 방법으로 연결!

각 하위 타입들은 -> 모두 상위 타입인 인터페이스에 정의된 실제 기능들을 구현하는데 

-> 이들 클래스는 실제 구현을 제공한다는 의미하여 == 콘크리트 클래스라 함


## 추상 타입을 이용한 구현 교체의 유연함

- 근데 콘크리트 클래스를 직접 사용해도 문제가 없는데, 왜 추상 타입을 사용할까? 

- 콘크리트 클래스(구현 클래스)를 사용하게 되면, 
- 그 클래스의 책임이 아닌 다른 클래스의 책임까지도 갖게 되는 경우가 생길 수있다.

- 예를 들어 어떤걸 만들어 주는 클래스가 있다고 하자 
  - 이 클래스는 다음과 같은 기능을 제공한다고 가정하자 
    - 빵을 만들어주는 콘크리트 클래스와 
    - 케이크를 만들어주는 콘크리트 클래스가 있으면, 
  - 빵인지, 케이크 인지에 따라서 콘크리트 클래스를 선택해야 한다.
  - 그렇게 되면, 만든다 라는 책임만 지면 되는데, 어떤걸 만드냐에 따라 코드가 바뀜 

- 이럴때, 클래스가 바뀌지 않도록 하는 방법에는 두가지가 존재 

1. 추상 타입의 객체를 생성하는 기능을 별도로 분리, -> 그 객체를 사용해서 생성
2. 생성자 (또는, 다른 메서드)를 이용해서 사용할 ByteSource를 전달받기 

### 객체를 생성하는 기능을 별도로 분리

```java
public class FoodFactory {
    public Food create() {
        if (isBread()) {
            return new Bread();
        } else {
            return new Cake();
        }
    }

    private boolean isBread() {
        String food = System.getProperty("food");
        return food.equals("bread");
    }

    private static FoodFactory instance = new BreadFactory();

    public static FoodFactory getInstance() {
        return instance;
    }

    private FoodFactory() {
    }
}
```

- 2장 : 객체는 책임즐 작게 가질수록 변경에 대한 유연함을 가진다
- 책임을 분리시켜주면, 변경에 대한 유연함을 가질 수 있다. 

- 책임을 분리할 수 있었던 것은 -> 추상화를 한 덕분

> 즉, 추상화는 
> - 공통된 개념을 도출해서 추상 타입을 정의해주기도 하지만,
> - 많은 책임을 가진 객체로부터 책임을 분리하는 촉매제
> 

## 변화되는 부분을 추상화하기 
- 경험하지 않는 분야는 추상화 하기 어렵다 
- 경험하지 않는 분야라도 추상화 할 수 있는 방법이 하나 있는데, 
  - 그것은 바로 변화되는 부분을 추상화하는 것 

- 요구사항이 바뀔 때 변화되는 곳 

- 추상화가 되어 있지 않은 코드는 **주로 동일 구조를 갖는 if-else 블록으로 드러남**


> - 추상화가 되어 있지 않은 코드는 **주로 동일 구조를 갖는 if-else 블록으로 드러남**


## 인터페이스에 대고 프로그래밍하기

- 여기서 말하는 인터페이스가 아니라 -> **오퍼레이션을 정의한 인터페이스**

> 실제 구현을 제공하는 콘크리트 클래스를 사용해서 프로그래밍 하지말고, 
> 
> -> 기능을 정의한 인터페이스를 사용해서 프로그래밍하라

- 그런데, 인터페이스는 최초설계에서 도출되기 보다는 
  - **요구사항의 변화와 함께 점진적으로 도출이 된다. **

- 즉, 인터페이스는 **새롭게 발견된 추상 개념을 통해서 도출됨!**

- 인터페이스에 대고 프로그래밍하기 규칙은 
  - 추상화를 통한 유연함을 얻기 위한 규칙!

- 주의할 점은, 유연함을 얻는 과정에서 타입(추상 타입)이 증가하고, 구조도 복잡해지기 때문에
  - 모든 곳에서 인터페이스를 사용해서는 안된다.
    - 이 경우, 불필요하게 프로그램의 복잡도만 증가시킬 수 있다.

- 인터페이스를 사용할 때는 -> **변화 가능성이 높은 경우에 한해서만!**

> 추상화된 인터페이스를 사용하면, (다소 구조는 복잡해 지지만) 변경의 유연함이라는 효과를 얻을 수 있다.
> 
> 변경 가능성이 매우 희박한 클래스에 대해 인터페이스를 만든다면, 오히려 프로그램의 구조만 복잡해지고, 유연함의 효과는 누릴 수 없는 그런 상황이 발생!

## 인터페이스는 인터페이스 사용자 입장에서 만들기 

- 인터페이스의 이름을 명확하게 짓지 않으면, 기능을 오해할 수 있다
- 의미를 명확하게 드러내야 한다!

## 인터페이스와 테스트 

- 아직 콘크리트 클래스가 구현이 되지 않아도, 
- 모킹 (가짜 객체)를 만들어 테스트할 수 있다!
- 이것이 인터페이스를 사용하는 장점 중 하나

