- 객체 지향을 잘하려면 -> 이와 대조되는 기법인 절차지향적으로 프로그램을 작성하면 안된다
- 객체 지향을 지원하는 언어를 사용하더라도, 실제 결과물은 객체 지향과 거리가 멀어질 수 있다

- 객체 지향적이지 않은 코드 (코드 변경이 점점 어려워지는) 가 나오는 이유는 
  - 객체 자체와 / 객체 지향의 핵심인 **캡슐화 및 추상화가 적용되지 않았기 때문**

## 절차지향 
- 절차지향은 **데이터**를 **조작**하는 코드를 별도로 분리해서 함수나 프로시저와 같은 형태로 구성하는 기법

- 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성
- 프로시저는 -> 다른 프로시저를 사용할 수도 있거나 || 각각의 프로시저가 같은 데이터를 사용할 수 있다

- 절차지향은 데이터와 데이터를 조작하는 프로시저로 구성되어있다.
- 이렇게 데이터를 공유하면서 사용하면 -> 자연스럽게 **데이터를 중심으로 구현**하게 된다.
- 최초의 기능 구현시 -> 절차지향적으로 코드를 구현하는건 쉽다. 
  - 하지만, **프로그램 규모가 커지고, 데이터 종류가 증가, 이를 사용하는 프로시저가 증가하게 되면 아래와 같은 문제가 발생 **

##### 절차지향적 코드가 규모가 커졌을 때 발생하는 문제점
1. 데이터 타입이나 의미를 변경 해야할 때 -> 함께 수정해야 하는 프로시저가 증가한다. 
2. **같은 데이터**를 프로시저들이 **서로 다른 의미로 사용**하는 경우가 발생

> 이러한 문제들로 인해 **프로그램의 규모가 커질수록 코드 변경이 어려워지는 원인이 된다.**


## 객체지향 
- 객체 지향은 (데이터 + 데이터와 관련된 프로시저)를 **객체라고 불리는 단위로 묶는다**
- 객체는 **프로시저를 실행하는데 필요한 만큼의 데이터를 가지고**, -> 객체들이 모여 프로그램을 구성한다.


- **객체는 자신만의 기능을 제공**하며 -> **각 객체들은 서로 연결**되어 -> **다른 객체가 제공하는 기능을 사용할 수 있다**.
- 객체는 **다른 객체에 기능을 제공하기 위해** -> 프로시저를 사용하는데, 
- 이때 프로시저는 **자신이 속한 객체의 데이터에만 접근할 수 있으며** -> 다른 객체에 속한 데이터에는 접근할 수 없다.

- 절차지향은 **모든 프로시저가 데이터를 공유한다.**

- 객체지향은 **객체 별로 데이터와 프로시저를 알맞게 정의해야한다.**
- 객체지향적으로 만드는 코드에서는 **객체의 데이터를 변경하더라도 -> 해당 객체로만 변화가 집중되고**, 
  - **다른 객체에는 영향을 주지 않기 때문에**
- 요구사항의 변화가 발생했을 때 절차지향 방식보다 **프로그램을 더 쉽게 변경할 수 있다.**
- = **유연함**


### 객체 

#### 1. 객체의 핵심은 기능을 제공하는 것

- 객체를 정의 할 때 사용되는 것은-> **객체가 제공해야할 기능**
- **객체가 내부적으로 어떤 데이터를 갖고 있는지로는 정의되지 않는다.**


#### 2. 인터페이스와 클래스 
- 객체는 객체가 제공하는 기능으로 정의되는데, -> 보통 객체가 제공하는 기능을 **오퍼레이션**이라고 부른다. 
- 즉, 객체는 오퍼레이션으로 정의가 된다.
- 객체가 제공하는 기능을 사용한다는 것은 결국 **객체의 오퍼레이션을 사용**한다는 의미


**오퍼레이션의 사용법을 시그니처라고 한다.**

시그니처는 아래의 요소로 구성되어 있다
- 기능 식별 이름
- 파라미터 및 파라미터 타입
- 기능 실행 결과 값 

**객체가 제공하는 모든 오퍼레이션의 집합을 객체의 인터페이스라고 부른다.**

- 위에서 말하는 인터페이스는 자바 언어의 인터페이스가 아니라, **객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어**
- 인터페이스는 **객체를 사용하기 위한 일종의 명세나 규칙**

서로 다른 인터페이스를 구분 할때 사용되는 명칭은 **타입(type)**


- 인터페이스는 객체가 제공하는 기능에 대한 명세서 일 뿐, 
  - **실제 구현을 정의하는 것은 클래스(class)**
  - -> 클래스는 오퍼레이션을 구현하는데 **필요한 데이터 및 오퍼레이션의 구현이 포함**


#### 3. 메세지 
- 객체지향에서 객체는 다른 객체에게 어떤 오퍼레이션을 실행해달라는 요청을하고, 전달하고 받는다.
- **이때 오퍼레이션의 실행을 요청하는 것을 == 메세지**라고 한다


### 객체의 책임과 크기 
- 객체는 객체가 제공하는 기능으로 정의할 수 있다. 
- 이는 다시 말하면 **객체마다 자신만의 책임이 있다는 의미**

- 한 객체가 갖는 책임을 정의하는 것이 == **타입/인터페이스**

- 그럼 객체가 갖는 책임은 어떻게 결정할까?
  - -> 이 결정을 하는 것이 객체 지향 설계의 출발점 

> 참고 
> 
> 객체가 책임을 갖는다는 것은 == **객체가 역할을 수행한다**는 의미

 
**객체지향 설계**
1. 프로그램을 만들기 위해 **필요한 기능 목록을 정리**
- 기능들을 어떻게 객체들에게 분배하느냐에 따라서 객체의 구성이 달라진다.
- 객체 지향적으로 프로그래밍을 할 때, 가장 어려우면서 중요한 것이 **객체마다 기능을 할당하는 과정**

객체마다 기능을 어떻게 할당할지 결정하는 것은 어렵다. 

- 하지만, 객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 있다!
  - 그 규칙은 **객체가 갖는 책임의 크기는 작을수록 좋다**
  - 즉, 객체가 제공하는 기능의 개수가 적다는 걸 의미 

**객체가 갖는 책임의 크기는 작으면 좋은 이유**

- 한 객체에 많은 기능이 포함되면, 그 기능과 관련된 데이터들도 한 객체에 모두 포함된다. 
- 이렇게 되면, -> 객체에 정의된 **많은 오퍼레이션들이 데이터들을 공유하는 방식**으로 프로그래밍 된다는 것을 의미
- 이는 곧 **데이터 중심으로 개발되는 절차지향 방식과 동일해진다.**

> 따라서, **객체가 갖는 책임이 커질수록 절차지향적으로 구조가 변질되며,**
> 
> 절차지향의 큰 단점인 기능 변경의 어려움 문제가 발생한다. 

- 위의 말을 다르게 생각하면, **객체가 갖는 책임의 크기는 작아질수록 객체지향의 장점인 변경의 유연함을 얻을 수 있다.**
  - 객체의 크기와 관련된 원칙인 SRP와 연관됨 
    - SRP는 객체는 단 한개의 책임만을 가져야 한다는 원칙

### 의존 
객체지향적으로 프로그램을 구현하다 보면, **다른 객체가 제공하는 기능을 이용**해서 -> **자신의 기능을 완성하는 객체**가 출현
 
e.x. 흐름제어 객체

한 객체가 다른 객체를 이용한다는 것은,
- 실제 구현에서는 한 객체의 코드에서 **다른 객체를 생성**하거나
- **다른 객체의 메서드를 호출**한다는 듰

이렇게 한 객체가 **다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때** -> 그 객체에 **의존한다**라고 표현 
- 객체를 생성 / 메서드를 호출 / 파라미터로 전달 받는 경우 에도 의존한다고 볼 수 있다.

**다른 타입에 의존한다는 것은 -> 의존하는 타입에 변경이 발생할 때 -> 나도 함께 변경될 가능성이 높다**

의존의 영향은 **꼬리에 꼬리를 문 것처럼 전파되는 특징을 갖는다.**

- 이런 이유 때문에 **순환 의존**이 발생할 경우, 변경의 여파가 나 자신에게 다시 영향을 줄 수 있다. 

순환 의존이 발생하지 않도록 하는 원칙중의 하나로 **의존 역전 원칙 (DIP)**


### 캡슐화 
객체 지향의 장점은 한 곳의 구현변경이 -> **다른 곳에 변경을 가하지 않도록 해준다**

> 즉, 수정을 좀 더 원활하게 할 수 있도록 하는 것이 **객체 지향적으로 프로그래밍을 하는 이유**
- 객체 지향은 기본적으로 캡슐화를 통해서 -> **한 곳의 변화가 다른 곳에 미치는 영향을 최소화**  


**캡슐화**는 객체가 **내부적으로 기능을 어떻게 구현하는지를 감추는 것**
- 이를 통해 **내부의 기능 구현이 변경**되더라도 -> 그 기능을 사용하는 코드는 영향을 받지 않도록 해준다.

> 즉, 내부 구현 변경의 유연함을 주는 기법이 바로 **캡슐화**

**캡슐화를 하지 않는 경우**
- 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에
- -> 요구사항의 변화로 인해 데이터의 구조나 쓰임새가 변경되면 
- -> 이로 인해 데이터를 사용하는 코드들도 연쇄적으로 수정해줘야 한다.


**캡슐화를 통해 얻는 장점**
- 내부 변경 변경의 유연성 획득 
- 즉, 캡슐화를 잘 할수록 보다 쉽게 구현을 변경할 수 있게 된다.

#### 캡슐화를 위한 두 개의 규칙
- 절차지향적인 코드에 익숙한 사람들에게 객체지향적인 코드를 작성하게 도와주는 규칙이 있다. 

1. TDA (Tell, Don't Ask)
2. 데미테르의 법칙

**TDA**
- **데이터를 물어보지 않고, 기능을 실행해 달라고 말하라는 규칙**
- e.x. 비즈니스 서비스 로직에서 데이터를 물어보지 않고, 데이터를 가지고 있는 객체에게 기능을 실행해 달라고 요청하는 것

**데미테르의 법칙**
- **메서드에서 생성한 객체의 메서드만** 호출
- **파라미터로 받은 객체의 메서드만** 호출
- **필드로 참조하는 객체의 메서드만** 호출

**데미테르 법칙 위반 경우**
```java
public void process(Member member) {
    if (member.getDate().getTime() < ...) //데미테르 법칙 위반
}
```
- 데미테르의 법칙을 따르려면, 위 코드를 **member 객체에 대한 한 번의 메서드 호출로 변경**해야함

**데미테르의 법칙을 지키지 않는 전형적인 증상**
- 연속된 get 메서드 호출하는 경우
- 임시 변수의 get 호출이 많은 경우


### 객체 지향 설계 과정
1. 제공해야 할 기능을 찾고, 또는 세분화 -> 그 **기능을 알맞은 객체에 할당** 
   1. 기능을 구현하는데 **필요한 데이터를 객체에 추가** / 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수 도 있다.
   2. **기능은 최대한 캡슐화** 해서 구현 
2. 객체 간에 **어떻게 메세지를 주고받을 지 결정**
3. 과정1과 과정2를 개발하는 동안 지속적으로 반복

- 객체의 크기는 한 번에 완성되기 보다는 구현을 진행하는 과정에서 점진적으로 명확해진다.
- 객체 설계는 한 번에 완성되지 않고 구현을 진행해 나가면서 점진적으로 완성된다.


---
# 키워드 
- 객체지향은 절차지향의 단점인 기능 변경의 어려움을 해결하기 위해 나온 패러다임  
- 객체지향은 데이터에 집중하기보다, 각각의 기능, 즉 타입에 집중한 패러다임이다. 
- 객체지향과 절차지향은 한 끝 차이, 기능의 책임을 적절하게 분배하는 것이 객체지향 설계의 핵심이다.
- 내가(객체) 변경되면 -> 나에게 의존하고 있는 코드에 영향을 준다.
  - 이런 의존관게로 순환 참조가 발생할 수 있는데, 그럼 내가 변경되면, 나에게 여파 발생할 수 있고, 이를 발생하지 않도록 하는 원칙이 DIP
- 내부 구현 변경의 유연함을 주는 기법이 캡슐화