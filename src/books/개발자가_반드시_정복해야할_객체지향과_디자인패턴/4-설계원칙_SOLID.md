지금까지 객체지향의 기본 내용들인 **책임 할당, 캡슐화, 다형성과 추상화, 그리고 조립을 통한 재사용**에 대해서 알아봤다

이 과정에서 -> 객체 지향 설계가 **어떻게 소프트웨어의 변경을 유연하게 할 수 있도록 해주는지** 알 수 있었다 .

---

이번 markdown에서는 **객체 지향적으로 설계하는데 기본이 되는 설계 원칙인 SOLID**에 대해서 살펴보자


SOLID 설계 원칙은
- 앞서 살펴 봤던 설계 관련 내용들을 체계적으로 정리한 것, 
- 이 원칙만으로도 좋은 설계를 하는데 큰 도움이 될 것!


##### SOLID 의 다섯 가지 원칙 
- **단일 책임 원칙** (Single Responsibility Principle) : SRP
- **개방-폐쇄 원칙** (Open-Closed Principle) : OCP
- **리스코프 치환 원칙** (Liskov substitution Principle) : LSP
- **인터페이스 분리 법칙** (Interface Segregation Principle) : ISP
- **의존 역전 원칙** (Dependency Inversion Principle) : DIP

- 각 원칙들은 서로 다른 내용이기보다는 -> **밀접하게 연결되어 있다.**


# 단일 책임 원칙 (Single Responsibility Principle)
- 객체 지향의 기본은 **책임**을 -> **객체에게 할당** 하는데 있다.
- **객체를 객체로 존재하게 하는 이유가 책임**인데,
- 단일 책임 원칙은 이 책임과 관련된 원칙 

> **클래스는 단 한개의 책임을 가져아 한다.**
> 
> **클래스를 변경하는 이유는 단 한개여야 한다**

- **클래스가 여러 책임을 갖게 되면** -> **그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문**에
  - -> 클래스가 한 개의 이유로만 변경되려면 -> 클래스는 한 개의 책임만을 가져야 한다. 

- SRP가 잘 지켜지지 않으면 -> 다른 원칙들도 그 효과가 반감되기 때문에 -> 최대한 지켜야 하는 원칙!

**어려운 원칙**
- **한 개의 책임에 대한 정의가 명확하지 않고,**
- **책임을 도출해 내기 위해서는** -> 다양한 경험이 필요하기 때문!

# 개방 폐쇄 원칙 (Open-Closed Principle)
- **확장에는 열려 있고, 변경에는 닫혀 있어야 한다.**

> 기능을 **변경하거나 확장**할 수 있으면서
> 
> -> 그 기능을 사용하는 코드는 **수정하지 않는다.** 

- 변경의 유연함과 관련된 원칙
---
- **확장되는 부분(변화되는 부분)을 추상화해서 표현**했기 때문 

**구현 방법**
- interface 를 사용해서 -> **추상화**를 통해 구현
- 상속과 확장을 통해 개발 -> 템플릿 메소드 패턴

### OCP 를 지키지 않을때의 문제점 
- 다운 캐스팅을 한다
- 비슷한 if-else 블록이 존재한다 

# 리스코프 치환 원칙 (Liskov substitution Principle)
- OCP를 받쳐주는 다형성에 관한 원칙 

> 상위 타입의 객체를 -> 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다

- 리스코프 치환 원칙은 **계약**과 **확장**에 대한 것

**리스코드 치환원칙이 지켜지지 않을 때의 문제**
- 상위 타입에서 지정한 리턴값의 범위를 벗어나는 값을 리턴하는 경우 

# 인터페이스 분리 법칙 (Interface Segregation Principle)

> **인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야 한다.**
> - **클라이언트는 자신이 사용하는 메서드에만 의존해야 한다**

# 의존성 역전 원칙 
> 고수준 모듈은 저수준 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.
> 
> 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

