객체지향의 주요 특징으로 **재사용**을 말하면서 -> 그 **예로 상속을 드는 경우**가 있다.

물론, 상속을 사용하면 재사용을 쉽게 할 수 있는 것은 분명하다 

하지만, **상속을 사용할 경우 여러 문제점이 있다.**

이 markdown에서 알아볼 내용 
- **상속**을 통한 재사용 과정에서 발생할 수 있는 **문제점**
- **객체 조립**을 통해 상속을 통한 **재사용의 단점을 해소**하는 방법

## 상속과 재사용 

- 상속은 기능을 재사용하는 매력적인 방법 중 하나 
- 하지만, **상속은 변경의 유연함이라는 측면에서 치명적인 단점을 가진다**

### 상속을 통한 재사용의 단점, 1. 상위 클래스 변경의 어려움 
**상속은 상위 클래스의 변경을 어렵게 만든다**

- 어떤 클래스를 상속받는다는 것은 -> **그 클래스에 의존한다**
- 따라서, 의존하는 클래스의 코드가 변경되면 -> **영향을 받을 수 있는 것!**
- 계층도가 커질수록 점점더 상위 클래스를 변경하는 것은 어려워진다.

### 상속을 통한 재사용의 단점, 2. 클래스의 불필요한 증가 
유사한 기능을 확장하는 과정에서 -> **클래스의 개수가 불필요하게 증가할 수 있다.**

- 여러 요구에 대응하는 클래스를 상속을 통해 만들다보면, 
- **상속을 통한 기능 재사용을 하면** -> **클래스의 개수는 함께 증가**

### 상속을 통한 재사용의 단점, 3. 상속의 오용 
상속 자체를 잘못 사용할 수 있다.

e.x. 컨테이너 수화물 목록을 관리하는 클래스를 만들 때, ArrayList기능을 상속받아서 개발 

잘못된 기능을 상속받아서 사용할 수 있다. 그 클래스를 사용하는 입장에서 잘못 사용할 수 있다. 

- 이런 문제가 발생하는 이유는 **IS-A 관계**가 성립되지 않아서!(~는 ~이다)
- 컨테이너는 ArrayList이다 라는 관계가 성립되지 않는다.
  - 즉, 컨테이너와 ArrayList는 **다른 책임을 갖는다**

---

상속을 사용했을 때 발생하는 세가지 문제점 
1. 상위 클래스 변경의 어려움 
2. 클래스 개수 증가 
3. 상속의 오용 문제 

이 문제를 해소할 수 있는 방법은 **객체 조립**을 사용하는 것이다.

## 조립을 이용한 재사용 
객체 조립(composition)은 **여러 객체를 묶어서** -> **더 복잡한 기능을 제공하는 객체를 만들어 나가는** 과정

- 객체 지향 언어에서 객체 조립은 -> 보통 필드에서 참조하는 방식으로 구현
- 한 객체가 다른 객체를 조립해서 필드로 갖는다는 것은 == **다른 객체의 기능을 사용한다는 의미**


**장점**
- 조립을 이용하면 **불필요한 클래스 증가를 방지**할 수 있다
- **런타임에 조립 대상 객체를 교체**할 수 있다.
  - 상속의 경우, 컴파일 타임에 결정되어 런타임에 교체가 안된다.

**단점**
- 상대적으로 런타임 구조가 복잡하다
- 상속보다 구현이 더 어렵다 

하지만, 장기적 관점에서 구현/구조의 복잡합 보다 ->**변경의 유연함을 확보하는 데서 오는 장점이 더 큼!**

> **상속보다는 객체 조립을 사용할 것!** 
> 
> - 물론 모든 상황에서 객체조립을 사용하라는 것은 아니지만, 
> - 상속에서 변경의 관점에서 유연함이 떨어지니, 
> - -> 객체 조립을 먼저 고민해보자


#### 위임 
위임 (delegation)은 내가 할일을 -> 다른 객체에 넘긴다는 의미 
- 보통 조립 방식을 이용해서 의임을 구현한다!

```java
public abstract class Figure {
  private Bounds bounds = new Bounds();
    
  public boolean conatains(Point point) {
      /* bounds 객체에 처리를 위임!*/
    return bounds.contains(point.getX(), point.getY()); 
  }
}
```
- 보통 위임은 조립과 마찬가지로 요청을 위임할 객체를 필드로 연결
  - 하지만, 꼭 필드로 정의해야 하는 것은 아니다!
- 위임의 의도는 **다른 객체에서 내가 할 일을 넘긴다는데 있으므로** 
  - 객체를 새로 생성해서 -> 요청을 전달한다 해도 위임이라고 할 수 있다!
```java
// 객체를 새로 생성해서 요청을 전달하는 경우
public abstract class Figure {
  public boolean contains(Point point) {
   Bounds bounds =new Bounds(x, y, width, height);
   return bounds.contains(point);
  }
}
```

- 객체 지향은 **책임에 따라 객체들이 세분화되는 특징**을 갖는다 
- -> 따라서 객체 지향적으로 구현을 하면 **자연스럽게 많은 객체들이 만들어지고**, 
  - **이 과정에서 조립과 위임을 통해 객체를 재사용!**



> 위임을 사용하면, 내가 바로 실행할 수 있는걸 , **다른 객체에 한 번 더 요청하게 됨**
> 이 과정에서 메소드 호출이 추가되기 때문에 성능에 영향을 줄 수 있다.
> 하지만, 대부분의 경우, **위임을 통해 얻을 수 있는 유연함 / 재사용의 장점이 크다**


#### 그럼 상속은 언제 사용하나?
- 상속은 **재사용이라는 관점이 아닌** 
  - **기능의 확장이라는 관점**에서 상속을 적용해야 한다!
- 또한, **명확한 IS-A 관계가 성립**해야 한다!


e.x. android UI 위젯

- 상속은 **명확한 IS-A 관계에서** 점진적으로 상위 클래스의 기능을 확장해 나갈 때 사용!

- 하지만, 명확한 IS-A 관계가 보여도 
  - 이후에 **클래스가 불필요하게 증가하는 문제 발생**하거나
  - **상위 클래스의 변경이 어려워 지는** 등
- 문제가 발생하면 -> **조립으로의 전환을 고민**해야 함!