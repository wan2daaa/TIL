# Node.js

- 서버 측 자바스크립트 런타임 환경 
- 브라우저 밖에서 자바스크립트를 사용하는 V8 엔진을 사용함 
- Node.js 이전에는 -> 논블로킹/비동기 API를 서버 환경에서 구현하기 어려웠음 
  - 동시 실행되는 스레드와 공유 자원을 프로그래머가 직접 만들고 관리해야 했기 때문 

- 비동기로 API를 제공하는 것이 편리하다고 생각한 라이언달은 **이벤트 기반 비동기 환경**을 만들고 Node.js 라는 런타임 환경을 처음 소개 


## Node.js는 서버에서 어떻게 자바스크립트를 실행할까

- Node.js는 **V8 자바스크립트 엔진**과 / **libuv 및 C/C++**에 의존성을 가진 자바스크립트 런타임

> **런타임이란?** 
> 자바스크립트로 된 프로그램을 실행할 수 있는 프로그램
> 
> 예를 들어, Java는 JRE(Java Runtime Environment)에서 실행됨 
> 
> C# 코드는 CLR(Common Language Runtime)이라는 런타임에서 실행됨 



### Node.js 구성요소 

- C++
- 자바스크립트
- 파이썬 (파이썬 코드는 빌드와 테스트에만 사용됨!)
- 등으로 이루어짐 

---
- Node.js는 각 계층이 각 하단에 있는 API를 사용하는 계층의 집합으로 구성됨 

[node.js 돌아가는 과정    ](http://latentflip.com/loupe/?code=ZnVuY3Rpb24gbXlGdW5jdGlvbjMoKSB7CiAgY29uc29sZS5sb2coJ0ZFQyAzIGhhcyBiZWVuIGNyZWF0ZWQuJyk7Cn0KCmZ1bmN0aW9uIG15RnVuY3Rpb24yKCkgewogIGNvbnNvbGUubG9nKCdGRUMgMiBoYXMgYmVlbiBjcmVhdGVkLicpOwogIG15RnVuY3Rpb24zKCk7Cn0KCmZ1bmN0aW9uIG15RnVuY3Rpb24xKCkgewogIGNvbnNvbGUubG9nKCdGRUMgMSBoYXMgYmVlbiBjcmVhdGVkLicpOwogIG15RnVuY3Rpb24yKCk7Cn0KCm15RnVuY3Rpb24xKCk7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

1. Node.js 애플리케이션 
2. Node.js API (http, fs, crypto, buffer...)
3. Node.js 바인딩(js 에서 C/C++ 함수를 호출할 수 있게 해줌) | Node.js 표준 라이브러리 | C++ 애드온 
4. V8 | libuv (비동기 I/O에 초점을 맞춘 멀티플랫폼을 지원하는 라이브러리, 이벤트 루프, 스레드 풀)
5. C-Ares | HTTP 파서 | OpenSSL | zlib
6. OS

- 사용자 코드(js) 는 Node.js API 를 사용하고, 
- Node.js API는 Node.js 바인딩을 사용하거나, 직접만든 C++ 애드온을 호출 
- C++ 에서는 V8을 사용해 js를 해석(JIT 컴파일러) 및 최적화 하고, 어떤 코드냐에 따라 C/C++ 종속성이 있는 코드를 실행
- 또한, DNS, HTTP 파서, OpenSSL, zlib 이외의 C/C++ 코드들은 libuv의 API를 사용해 OS에 알맞는 API 사용 


- Node.js 의 구성요소중 특히 **V8 , libuv 가 중요**
  - V8은 자바스크립트 코드를 실행하게 해주고,
  - libuv 는 이벤트 루프 및 운영체제 계층 기능을 사용하도록 API 제공


### V8 엔진 
- C++ 로 만든 오픈 소스 자바스크립트 엔진 

> **엔진이란?**
> 사용자가 작성한 코드를 실행하는 프로그램

- 엔진은 
  - 파서, 
  - 컴파일러, 
  - 인터프리터,
  - 가비지 컬렉터,
  - 콜 스택 (현재 실행중인 서브 루틴에 관한 정보를 저장하는 스택)
  - 힙 (객체나 동적 데이터가 저장되는 메모리 공간, **자료구조의 힙 아님!**)
  

으로 구성됨


- 인터프리터 역할을 하는 이그니션과 컴파일러 역할을 하는 터보팬을 사용해 컴파일 

#### V8 엔진 코드 컴파일 단계 

1. js 코드가 파서에 전달됨 
2. 추상 구문 트리로 만들어짐 (AST)
3. 이그니션 인터프리터에 전달되면, 이그니션은 추상 구문 트리를 -> 바이트 코드로 변환
4. 최적화가 필요한 경우, 터보팬 컴파일러에 전달
5. 터보팬에서 컴파일 과정을 걸쳐서 -> 바이너리 코드가 됨
6. 바이너리 코드가 최적화가 잘 안된 경우 -> 다시 최적화를 해제하고, -> 이그니션의 인터프리터 기능을 사용!


- 이처럼 인터프리터와 컴파일러의 장점을 동시에 가지고 있는 프로그램을 == **JIT(just in time)컴파일러 라고 함**

##### JIT 컴파일러
- **장점:** 속도가 빠르며, 적재적소에 최적화할 수 있다.
- **단점:** 컴파일러가 인터프리터가 동시에 실행되어 메모리를 더 많이 쓴다.

##### 이그니션 인터프리터와 터보팬 컴파일러의 특징 

| 이그니션 인터프리터                                                      | 터보팬 컴파일러                                         |
|-----------------------------------------------------------------|--------------------------------------------------|
| - 매우 빠른 초기화<br/>- 매우 컴팩트한 바이트 코드 생성<br/>- **자주 실행되지 않는 코드에 적합** | - 매우 빠른 기계어 생성<br/>- 최적화 제공<br/>- 자주 실행되는 코드에 적합 |


### 이벤트 루트와 운영체제 간 비동기 API 및 스레드 풀을 지원하는 **libuv** 
- V8 엔진을 사용해서 서버에서 js를 실행 가능 
- 그럼 Node.js는 HTTP, 파일, 소켓 통신 IO 기능 등 **js에는 없는 기능을 어떻게 제공할까?**
    - libuv 라는 C++ 라이브러리를 사용해 해결

- libuv는 **비동기 입출력, 이벤트 기반에 초점을 맞춘 라이브러리**

> 그래서, js에서 C++ 코드를 실행할 수있게 해둠
> - js로 C++ 코드를 감싸서 사용 (== C++ 바인딩)


- libuv는 다양한 플랫폼(linux, windows, mac)에서 사용할 수 있는 **이벤트 루프를 제공**
- 또한, 네트워크, 파일 IO, DNS, 스레드 풀 기능을 추가로 제공


### Node.js 아키텍처 

- Node.js 구조를 요약하면, 
  - 자바스크립트 코드 실행에 필요한 런타임으로 -> V8 엔진을 사용
  - 자바스크립트 런타임에 필요한 이벤트 루프 및 운영체제 시스템 API를 사용할 때 -> libuv 라이브러리 사용

- p082

1. 애플리케이션에서 요청이 발생하면 -> V8 엔진은 자바스크립트 코드로 된 요청을 바이트 코드나 기계어로 변경 
2. 자바스크립트로 작성된 Node.js API는 C++ 로 작성된 코드를 사용
3. V8 엔진은 이벤트 루프로 libuv를 사용하고, 전달된 요청을 libuv 내부의 이벤트 큐에 추가 
4. 이벤트 큐에 쌓인 요청은 -> 이벤트 루프에 전달되고, **운영체제 커널에 비동기 처리**를 맡김. 운영체제 내부적으로 비동기 처리가 힘든 경우(DB, DNS룩업, 파일 처리 등) -> 워커 스레드에서 처리
5. 운영 체제의 커널 또는 워커 스레드가 완료한 작업은 -> 다시 이벤트 루프로 전달
6. 이벤트 루프에서 콜백으로 전달된 요청에 대한 완료 처리를 하고 V8엔진에 넘김 
7. 완료 처리된 응답을 Node.js 애플리케이션으로 전달 


> **Node.js는 싱글 스레드 라고 했는데, 워커 스레드가 있으면, 싱글 스레드가 아니지 않나?**
> - Node.js의 **이벤트 루프 부분이 싱글 스레드**, 
> - 운영체제에서 비동기 I/O를 지원하지 않거나, 구현이 복잡한 경우에는 
>   - -> libuv 내부의 스레드 풀을 사용 (블로킹 처리 -> 워커 스레드 -> 스레드 풀)
> - 즉, Node.js의 프로세스는 
>   - 이벤트 루프에 사용하는 싱글 스레드 하나 와
>   - 비동기 처리를 하는 스레드 풀로 구성되어 있음


