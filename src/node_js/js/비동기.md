## 동기

- 프로그래밍에서 **작업은 차례대로 실행되며 -> 이전 작업이 완료될 때 까지 중단할 수 없다**
- 모든 작업은 이전 작업의 실행이 완료될 때까지 기다려야함

## 비동기

- 프로그래밍에서 **임의의 순서로 또는 동시에 작업이 실행**될 수 있다

### 자바스크립트에서 비동기를 처리하는 방법

- 자바스크립트는 런타임(브라우저, Node.js)에서 싱글 스레드로 동작
    - 싱글 스레드로 동작한다는 것은 = 한 번에 하나의 작업만 처리할 수 있다

- 싱글 스레드로 동작하지만,
    - 콜백
    - 프로미스
    - async / await

방법을 사용해서 자바스크립트에서 비동기 처리 가능

#### 콜백

- 함수의 파라미터로 함수를 전달 하여 -> 비동기 처리가 끝났을 때 전달된 함수를 실행하는 방식
- 콜백은 가독성 안좋음 , 유지보수 및 디버깅이 힘듬

#### 프로미스 (Promise 객체 사용)

- 콜백 대신 사용할 수 있는 방법
- 비동기 작업이 완료되면 -> 결과를 반환하는 객체

**프로미스 객체**

- 상태를 가지고 있으며,
    - 처음에는 대기였다가
    - 작업이 완료되면 -> **성공 또는 실패 상태**가 됨
    - `.then()`, `.catch()` 메서드를 사용하여 성공과 실패에 대한 처리 가능!

#### async / await

- **프로미스를 사용하는 비동기 작업을 동기적으로 처리하는 것처럼** 코드를 작성할 수 있다.
- `async`가 붙어있는 함수를 실행할 때 -> **`await`를 사용하여 비동기 작업이 완료될 때까지 기다림.**

### 콜백 함수

- 비동기는 현재 코드의 실행 결과를 받지 않고(X) -> 이후 코드를 수행하는 기법
- 컴퓨팅 자원을 효율적으로 사용하는 기법 이지만, 정확한 순서를 지켜 수행해야 하는지를 고려해서 처리

- 콜백은 실행 가능한 함수를 인자로 전달 -> 특정 상황이 발생할 때 호출하게 하는 방식

### Promise 객체

- Promise는 자바스크립트에서는 **비동기 실행을 동기화하는 구문으로 사용**

- 약속은 `이행` , `거절`, `대기` 세 가지의 상태를 가질 수 있다.

- 자바스크립트에서는 `이 코드를 미래의 어느 시점에 실행할거야`라고 약속하는 객체로 Promise를 사용
- **Promise는 객체라서 -> new 연산자로 인스턴스를 생성할 수 있다.**

#### Promise 의 문제점

- 콜백 함수보다는 확실히 편하다
- 하지만, `.then(), .catch()`함수를 연결하는 체이닝 방식을 사용하기가 어렵고,
    - 거기에 더 복잡한 로직을 추가하고 예외 처리까지 해야되는 상황이라면 더 어렵다.

### async / await

- 기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완, 가톡성 높은 코드를 작성할 수 있다

#### async

- **async** : 함수 앞에 붙이는 키워드
    - async 는 asynchronous 라는 의미
- async 함수만 보고도 비동기 함수라는 것을 유츄할 수 있다!
    - 여기서 말하는 비동기는 콜백이 아니라(X)  -> Promise!

> **즉, async가 붙은 함수는 == 프로미스를 반환한다! 라고 이해하면된다**

```javascript
async function myName() {
    return "WANE";
}

console.log(myName()); // Promise { 'WANE' }
```

#### await

- await 는 기다린다는 영어
- 즉, 성공 또는 실패로 Promise 객체의 실행이 완료되기를 기다림
    - 그러므로 await 뒤에는 Promise가 오게 됨
- await는 async 키워드를 사용한 함수에서만 사용 가능!

```javascript
async function myName() {
    return "WANE";
}

async function showName() {
    const name = await myName(); // Promise { 'WANE' }
    console.log(name);
}

console.log(showName()); // WANE
```

- `await`는 `Promise` 객체가 `resolve` 또는 `reject` 상태가 될 때까지 기다린다

# 정리

- Promise가 필요한 경우 (setTimeOut()을 사용하거나, 여러 태스트를 동시에 실행해야 하는 경우)
- 이외에는 모두 async / await를 사용하는 것이 좋다
- 읽기 편한 코드가 디버깅에 유리하기 때문

- **비동기란, 해당 함수를 기다리지 않고 다음 코드를 실행하는 것!!!!!!!!!!!!**

| 구분    | callback                    | promise         | async/await       |
|-------|-----------------------------|-----------------|-------------------|
| 에러 처리 | 콜백 함수 내                     | catch() 메서드로 처리 | try-catch 블록으로 처리 |
| 가독성   | 간단한 경우 괜찮, <br/>하지만 점점 복잡해짐 | 가독성 좋음          | 가독성 좋음            |
| 중첩 처리 | 콜백 함수 내에서 처리                | then()메서드 사용    | await 키워드를 사용     |

> **async / await 정확히 이해하기**
> - async 함수 내에서 await 키워드를 만나면, 프로미스가 처리될 때까지 기다린다
> - 기다린다 때문에 해당 함수는 멈추고 동기적으로 되면 비동기가 아니지 않나? 라고 생각했는데,
>
> - 그것이 아니라, 그 함수는Promise 반환을 위해 멈추지만, async 함수 외 바깥에 있는 다른 함수들이 이벤트루프에 들어가면서 비동기로 처리 된다는 뜻!
>
> async 함수 내에서 await를 만나면 그 시점에서 해당 함수 내의 실행이 잠시 멈춥니다.
>
> 이 멈춤은 await가 기다리는 Promise가 해결될 때까지 지속됩니다.
>
> 그러나 이 멈춤은 해당 함수에만 국한됩니다.
>
> 자바스크립트의 이벤트 루프는 여전히 실행 중이며, 다른 비동기 작업이나 함수들은 계속해서 비동기적으로 처리될 수 있습니다.
