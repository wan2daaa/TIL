# 영속성 컨텍스트 
엔티티를 영구 저장하는 환경 

- 엔티티 매니저로 엔티티를 저장하거나 조회 -> 엔티티 매니저는 **영속성 컨텍스트에 엔티티를 보관하고 관리**
- `em.persist()` 메소드는 엔티티 매니저를 사용해서 **회원 엔티티를 영속성 컨텍스트에 저장**


- 엔티티 매니저를 생성할 때 -> **영속성 컨텍스트 하나가 만들어진다.**
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 가능하고, 또한 영속성 컨텍스트를 관리할 수 있다.
  - 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다.

## 영속성 컨텍스트의 특징 

### 영속성 컨텍스트와 식별자 값 
- 엔티티를 식별자 값(@Id)로 구분 
  - 따라서 **영속 상태는 식별자 값이 반드시 있어야 한다!**
- 식별자 값이 없으면 예외 발생 

### 영속성 컨텍스트와 데이터베이스 저장
- 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 DB에 저장될까? 
  - JPA는 **보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영** -> 이것을 flush

### 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
1. 1차 캐시
2. 동일성 보장 
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
   - 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용
   - JPA 수정의 기본 전략은 엔티티의 모든 필드를 업데이트
   - 필드가 많거나, 저장되는 내용이 너무 크면, 수정된 데이터만 사용해서 동적으로 update SQL 생성하는 전략 "`@DynamicUpdate`"
5. 지연 로딩


## 1차 캐시 
- 영속 상태의 엔티티는 모두 1차 캐시에 저장됨 

## 플러시 
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영, 동기화 하는것!

### 영속성 컨텍스트를 플러시 하는 방법 
- Transaction commit 시점에 자동으로 수행
- **JPQL 쿼리 실행시 플러시가 자동 호출** 

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티 찾음 
   - 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소에 등록된 쿼리를 데이터베이스에 전송한다.

## 병합: `merge()`
- **준영속 상태의 엔티티를 다시 영속 상태로 변경할 때**, 병합을 사용
- 준영속 상태의 엔티티를 받아서 **그 정보로 새로운 영속 상태의 엔티티를 반환**
- 

