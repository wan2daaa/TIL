# 동시성 제어

- **작성한 코드 한 줄은 동시에 수행될 수 있다.**
    - 하나의 자원(DB 하나 레코드, 서버 하나 변수..)을 두고 여러 개의 연산들이 경합
    - -> 데이터 정합성을 깨뜨릴 수 있다!

## 데이터베이스에서 동시성 이슈가 발생하는 일반적인 패턴

1. 공유자원 조회
2. 공유자원 갱신

## 동시성 이슈가 어려운 이유

1. 로컬에서는 대부분 하나의 스레드로 테스트
2. 이슈가 발생하더라도 오류가 발생하지 않는다
3. 코드에서 잘 보이지 않는다
4. 항상 발생하지 않고, 비결정적으로 발생...

## 동시성 제어하기

1. 동시성 제어를 해결하기 위한 가장 보편적인 방법은 락을 통한 줄세우기 (비관적 락)


**락을 통해 동시성을 제어할 때는, 락의 범위를 최소화 하는것이 중요**

- 락의 범위가 길어질 수록 커넥션풀 점유 시간이 길어지고, 커넥션풀 고갈이 생길 수 있다

- MySQL 에서는 트랜잭션의 커밋 혹은 롤백 시점에 잠금이 풀린다
    - -> 트랜잭션이 곧 락의 범위!
    - 트랜잭션 내에 s3 올리는 작업이 있으면 올리는 동안 락이 풀리지 않는다

- MySQL 에서는 읽기락과 쓰기락이 있다.

  |                      | 읽기락 (Shared Lock) | 쓰기락 (Exclusive Lock) |
    |----------------------|-------------------|----------------------|
  | 읽기락 (Shared Lock)    | O                 | 대기                   |
  | 쓰기락 (Exclusive Lock) | 대기                | 대기                   |
- 읽기락이 잠금을 획득한 상태에서 다른 읽기락이 들어와도 잠금을 공유함!
  - 다른 읽기락이 락을 점유해도 다른 읽기락도 읽을 수 있다
- 쓰기락은 읽기락이든, 쓰기락이든 점유하고 있으면 대기하게 된다

- 읽기락은 `SELECT ... FOR SHARE`
- 쓰기락은 `SELECT ... FOR UPDATE 또는 UPDATE, DELETE 쿼리`

- 매번 잠금이 발생할 경우, 성능 저하를 피할 수 없다!
 - 그래서 MySQL 에서 일반 SELECT 는 nonblocking consistent read 로 동작

**레코드락**
- MySQL 에서 잠금은 row 가 아니라 **인덱스를 잠근다**
  - -> **인덱스가 없는 조건으로 Locking Read 시 불필요한 데이터들이 잠길 수 있다**
    - **인덱스가 없는 조건으로 조회할 때 모든 데이터를 읽어서 잠그기 때문에 불필요한 데이터들이 잠길 수 있다!**

```sql
select * from performance_schema.data_locks; -- 락 확인 쿼리
-- 여기서 LOCK_MODE 가 X 라고 되어있으면 잠겨 있다는 뜻 

select * from information_schema.innodb_trx; -- 현재 트랜잭션 확인 
```

#### 참고로 공부해볼만한 방법 
- Java에서의 동시성 이슈 제어 방법
- 분산환경에서의 동시성 이슈 제어 방법
- MySQL의 넥스트 키락이 등장한 배경
- MySQL 외래키로 인한 잠금
- MySQL 데드락


##### 비관적 락의 단점
- 락을 통해 동시성을 제어하는 방법
- 락을 통한 동시성 제어는 불필요한 대기 상태를 만듬
- 동시성이 빈번하지 않는 쿼리로 인해 다른 쿼리가 대기한다면?

## 낙관적 락
- 동시성 이슈가 빈번하지 않길 기대하고, 어플리케이션에서 제어한다.
  - CAS(compare and set)을 통해 제어!
- 실패에 대한 처리를 직접 구현해야함 
  - 비동기로 처리하기도 하고, retry 로직을 구현하기도 함

- entity에 optimistic lock 을 걸어서 해결할 수 있다
  - JPA 에서는 `@Version` 을 통해 해결할 수 있다

  