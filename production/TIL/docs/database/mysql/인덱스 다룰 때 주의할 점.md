# 인덱스를 다룰 때 주의할 점 

## 인덱스를 설정할 때 카디널리티 고려하기
- 데이터의 식별 정도가 높은 걸로 하자!
- 성별 (남, 녀) 는 데이터를 절반밖에 못 버려서 탐색 범위가 크다
- **식별할 수 있는 데이터가 높은 것을 인덱스로 설정하자**

## 인덱스 필드 가공
- 인덱스를 타기 위해서는 **인덱스 필드와 비교하는 값이 동일한 타입**이어야 한다.
- **인덱스 필드를 가공을 하게 되면 인덱스를 타지 않는다**. 
```sql
-- age는 int type 일 때
SELECT *
FROM Member
WHERE age * 10 = 1

SELECT * 
FROM Member 
WHERE age = '1' -- 인덱스를 타지 않음

```
## 인덱스를 타지 않는 쿼리 

### NULL 조건을 사용하면 **테이블 풀 스캔이 발생!**
```sql
SELECT * FROM users WHERE ages IS NULL 
SELECT * FROM users WHERE ages IS NOT NULL
```
### LIKE 앞에 %를 사용하면 **인덱스를 타지 않음**
```sql
SELECT * FROM users WHERE name LIKE '%park' -- index 안탐 
SELECT * FROM users WHERE name LIKE 'park%' -- index 사용가능! 
```

### IN 연산자를 사용할 때 인덱스를 안 탈 수 도 있다!
- IN에 포함된 데이터들의 비율이 매우 높으면, 테이블 풀 스캔을 하는 것이 낫다고 판단할 수 있다 조심하자 

### 복합 인덱스에서 첫 인덱스가 첫 조건으로 적용하지 않았을 떄 
- 복합 인덱스에서 첫 인덱스가 첫 조건으로 적용하지 않았을 때, 인덱스를 타지 않는다
  - 꼭 순서대로 조건을 걸자!

## 하나의 쿼리는 하나의 인덱스 
- **하나의 쿼리에는 하나의 인덱스만 탄다!**
- **여러 인덱스 테이블을 동시에 탐색하지 않음!**
  - **index merge hint**를 사용하면 가능하긴 하다 
- WHERE, ORDER BY, GROUP BY 혼합해서 사용할 때에는 인덱스를 잘 고려해야함 
    - e.x. WHERE 문에서 인덱스를 탔는데, order BY 에서 인덱스를 타지 않으면 다시 재정렬해야해서 성능 저하가 발생할 수 있다


## 의도대로 인덱스가 동작하지 않을 수 있다. explain 으로 확인해보자
- 통계 데이터가 다를 수 있다! 

## 인덱스도 비용이다. 쓰기를 희생하고 조회를 얻는 것 

## 꼭 인덱스로만 해결할 수 있는 문제인가? 
- 조회 조건, 정렬 조건이 많이 바뀔 수 있다 
- 어느순간 인덱스로 해결하기 어려울 수 있다 
  - 다른 데이터베이스를 사용하거나 
  - 조회, 쓰기 모델 분리하거나
  - 캐싱하거나 
- 요즘 인덱스를 계속 추가한다면 다른 방법이 있는지 고민해보자

